\section{Исходная программа}

\begin{lstlisting}[language=C++,caption=bin/child.cpp,captionpos=b]
#include "child.h"
#include <cstdio>

int main(int argc, char* argv[]) {
    if (argc != 2) {
        std::fprintf(stderr, "Usage: %s <output_file>\n", argv[0]);
        return 1;
    }

    const char* shared_mem_name = "/shm";
    RunChildProcess(argv[1], shared_mem_name);
    return 0;
}
\end{lstlisting}

\begin{lstlisting}[language=C++,caption=child.h,captionpos=b]
#pragma once

void RunChildProcess(const char* output_file, const char* shared_mem_name);
\end{lstlisting}

\begin{lstlisting}[language=C++,caption=exceptions.h,captionpos=b]
#pragma once

#include <stdexcept>
#include <string>

class OsException : public std::runtime_error {
public:
    explicit OsException(const std::string& message) : std::runtime_error(message) {}
};
\end{lstlisting}

\begin{lstlisting}[language=C++,caption=os.h,captionpos=b]
#pragma once

#include <string>
#include <cstddef>
#include <signal.h>

using pipe_t = int;
using pid_t = int;
using signal_t = int;
using SignalHandler_t = void(*)(int);

extern const int ChildDeathSig;
extern const int BrokenPipeSig;
extern const int ChildDoneSig;

int CreatePipe(pipe_t fd[2]);
pid_t CloneProcess();
int Exec(const char* path);
void PrintLastError();
int WaitForChild();
int ClosePipe(pipe_t pipe);
int WritePipe(pipe_t pipe, void* buffer, std::size_t bytes);
int ReadPipe(pipe_t pipe, void* buffer, std::size_t bytes);
int LinkStdinWithPipe(pipe_t pipe);
int LinkStderrWithPipe(pipe_t pipe);
void AddSignalHandler(signal_t sig, SignalHandler_t handler);
int ReadFromStdin(char* buffer, std::size_t size);
void* CreateSharedMemory(const char* name, size_t size);
int CloseSharedMemory(void* addr, size_t size);
int UnlinkSharedMemory(const char* name);
void SendSignal(pid_t pid, signal_t sig);
\end{lstlisting}

\begin{lstlisting}[language=C++,caption=parent.h,captionpos=b]
#pragma once
#include "os.h"

void RunParentProcess();
void OnChildKilled(signal_t signum);
void OnChildDone(signal_t signum);
\end{lstlisting}

\begin{lstlisting}[language=C++,caption=child.cpp,captionpos=b]
#include "child.h"
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <unistd.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <signal.h>

static void* shared_mem = nullptr;
static pid_t parent_pid = -1;
const size_t SHARED_MEM_BUFFER = 1024;
static const char* g_output_file = nullptr;

static void OnParentSignal(int sig) {
    if (sig == SIGUSR2) {
        char* input = static_cast<char*>(shared_mem);
        float num = 0.0;
        int scanned = std::sscanf(input, "%f", &num);
        if (scanned != 1) {
            std::fprintf(stderr, "Error: failed to read first number\n");
            std::exit(1);
        }

        const char* p = input;
        while (*p && *p != ' ') p++;
        if (*p) p++;
        float divider = 0.0;
        while (std::sscanf(p, "%f", &divider) == 1) {
            if (divider == 0.0) {
                std::fprintf(stderr, "Error: division by zero occurred\n");
                std::exit(1);
            }
            num /= divider;
            while (*p && *p != ' ') p++;
            if (*p) p++;
        }

        FILE* out = std::fopen(g_output_file, "w");
        if (!out) {
            std::fprintf(stderr, "Error: failed to open output file '%s'\n", g_output_file);
            std::exit(1);
        }

        std::fprintf(out, "%.6f\n", num);
        std::fclose(out);

        kill(parent_pid, SIGUSR1);
        
        std::exit(0);
    }
}

void RunChildProcess(const char* output_file, const char* shared_mem_name) {
    g_output_file = output_file;
    parent_pid = getppid();

    int fd = shm_open(shared_mem_name, O_RDWR, 0666);
    if (fd == -1) {
        std::perror("child can't open shared memory");
        std::exit(-1);
    }

    shared_mem = mmap(nullptr, SHARED_MEM_BUFFER, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    close(fd);

    if (shared_mem == MAP_FAILED) {
        std::perror("child: mmap");
        std::exit(1);
    }

    signal(SIGUSR2, OnParentSignal);

    kill(parent_pid, SIGUSR1);

    pause();
}
\end{lstlisting}

\begin{lstlisting}[language=C++,caption=os.cpp,captionpos=b]
#include "os.h"
#include "exceptions.h"
#include <unistd.h>
#include <sys/wait.h>
#include <cstring>
#include <csignal>
#include <cstdio>
#include <sys/mman.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <signal.h>

const int ChildDeathSig = SIGCHLD;
const int ChildDoneSig = SIGUSR1;
const int BrokenPipeSig = SIGPIPE;

int CreatePipe(pipe_t fd[2]) {
    return pipe(fd);
}

pid_t CloneProcess() {
    return static_cast<pid_t>(fork());
}

int Exec(const char* path) {
    return execl(path, path, nullptr);
}

void PrintLastError() {
    // std::fprintf(stderr, "DEBUG: errno = %d\n", errno);
    perror("OS Error");
}

int WaitForChild() {
    return wait(nullptr);
}

int ClosePipe(pipe_t pipe) {
    return close(pipe);
}

int WritePipe(pipe_t pipe, void* buffer, std::size_t bytes) {
    return static_cast<int>(write(pipe, buffer, bytes));
}

int ReadPipe(pipe_t pipe, void* buffer, std::size_t bytes) {
    return static_cast<int>(read(pipe, buffer, bytes));
}

int LinkStdinWithPipe(pipe_t pipe) {
    return dup2(pipe, STDIN_FILENO);
}

int LinkStderrWithPipe(pipe_t pipe) {
    return dup2(pipe, STDERR_FILENO);
}

void AddSignalHandler(signal_t sig, SignalHandler_t handler) {
    signal(sig, handler);
}

int ReadFromStdin(char* buffer, std::size_t size) {
    return static_cast<int>(read(STDIN_FILENO, buffer, size));
}

void* CreateSharedMemory(const char* name, size_t size) {
    int fd = shm_open(name, O_CREAT | O_RDWR, 0666);
    if (fd == -1) {
        PrintLastError();
        return nullptr;
    }

    if (ftruncate(fd, size) == -1) {
        PrintLastError();
        close(fd);
        return nullptr;
    }

    void* addr = mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    close(fd);

    if (addr == MAP_FAILED) {
        PrintLastError();
        return nullptr;
    }

    return addr;
}

int CloseSharedMemory(void* addr, size_t size) {
    return munmap(addr, size);
}

int UnlinkSharedMemory(const char* name) {
    return shm_unlink(name);
}

void SendSignal(pid_t pid, signal_t sig) {
    kill(pid, sig);
}
\end{lstlisting}

\begin{lstlisting}[language=C++,caption=parent.cpp,captionpos=b]
#include "parent.h"
#include "os.h"
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

const std::size_t KBUFFER = 100;
const std::size_t KSHARED_MEM_SIZE = 1024;
static pid_t child_pid = -1;
static void* shared_mem = nullptr;
static const char* KSHARED_MEM_NAME = "/shm";
static int child_finished = 0;
static int child_exited_with_error = 0;
static int child_ready = 0;

void OnChildExit(signal_t signum) {
    if (signum == SIGCHLD) {
        int status;
        pid_t pid = waitpid(child_pid, &status, WNOHANG);
        if (pid == child_pid) {
            if (WIFEXITED(status)) {
                int exit_code = WEXITSTATUS(status);
                if (exit_code != 0) {
                    child_exited_with_error = 1;
                    std::fprintf(stderr, "Child process exited with error code: %d\n", exit_code);
                    std::exit(-1);
                }
            } else if (WIFSIGNALED(status)) {
                std::fprintf(stderr, "Child process was terminated by signal: %d\n", WTERMSIG(status));
                std::exit(-1);
            }
        }
    }
}

void OnChildKilled(signal_t signum) {
    if (shared_mem) {
        CloseSharedMemory(shared_mem, KSHARED_MEM_SIZE);
    }
    UnlinkSharedMemory(KSHARED_MEM_NAME);
    std::fprintf(stderr, "Child process was killed by signal %d\n", signum);
    std::exit(-1);
}

void OnChildDone(signal_t signum) {
    if (signum == SIGUSR1 && !child_ready) {
        child_ready = 1;
    } else if (signum == SIGUSR1 && child_ready) {
        child_finished = 1;
        std::printf("Child process completed succesfully.\n");
        std::printf("Result written to file.\n");
    }
}

void RunParentProcess() {
    AddSignalHandler(SIGCHLD, OnChildExit);
    AddSignalHandler(SIGUSR1, OnChildDone);

    std::printf("Enter result file name: ");
    char output_file[KBUFFER];
    if (!std::fgets(output_file, KBUFFER, stdin)) {
        std::fprintf(stderr, "Error reading file name from stdin\n");
        std::exit(1);
    }
    output_file[strcspn(output_file, "\n")] = '\0';

    std::printf("Enter numbers (separator - space): ");
    char numbers_line[KBUFFER];
    if (!std::fgets(numbers_line, KBUFFER, stdin)) {
        std::fprintf(stderr, "Error reading numbers from stdin\n");
        std::exit(1);
    }

    shared_mem = CreateSharedMemory(KSHARED_MEM_NAME, KSHARED_MEM_SIZE);
    if (!shared_mem) {
        std::fprintf(stderr, "Failed to create shared memory\n");
        std::exit(-1);
    }

    pid_t pid = CloneProcess();

    if (pid == 0) { // child
        execl("./child", "./child", output_file, nullptr);

        PrintLastError();
        std::exit(1);
    } else if (pid == -1) {
        PrintLastError();
        std::exit(1);
    } else { // parent
        child_pid = pid;

        while (!child_ready) {
            pause();
        }

        std::strncpy(static_cast<char*>(shared_mem), numbers_line, KSHARED_MEM_SIZE - 1);
        static_cast<char*>(shared_mem)[KSHARED_MEM_SIZE - 1] = '\0';

        SendSignal(pid, SIGUSR2);
        
        while (!child_finished && !child_exited_with_error) {
            pause();
        }

        CloseSharedMemory(shared_mem, KSHARED_MEM_SIZE);
        UnlinkSharedMemory(KSHARED_MEM_NAME);
    }
}
\end{lstlisting}

\begin{lstlisting}[language=C++,caption=main.cpp,captionpos=b]
#include "parent.h"

int main() {
    RunParentProcess();
    return 0;
}
\end{lstlisting}
\section{Strace}
\begin{verbatim}
execve("./main", ["./main"], 0x7ffc5410c180 /* 27 vars */) = 0
brk(NULL)                               = 0x63b60b7ac000
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7757d2465000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=20919, ...}) = 0
mmap(NULL, 20919, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7757d245f000
close(3)                                = 0
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\220\243\2\0\0\0\0\0"..., 832) = 832
pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
fstat(3, {st_mode=S_IFREG|0755, st_size=2125328, ...}) = 0
pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
mmap(NULL, 2170256, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7757d2200000
mmap(0x7757d2228000, 1605632, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x28000) = 0x7757d2228000
mmap(0x7757d23b0000, 323584, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b0000) = 0x7757d23b0000
mmap(0x7757d23ff000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1fe000) = 0x7757d23ff000
mmap(0x7757d2405000, 52624, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7757d2405000
close(3)                                = 0
mmap(NULL, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7757d245c000
arch_prctl(ARCH_SET_FS, 0x7757d245c740) = 0
set_tid_address(0x7757d245ca10)         = 44592
set_robust_list(0x7757d245ca20, 24)     = 0
rseq(0x7757d245d060, 0x20, 0, 0x53053053) = 0
mprotect(0x7757d23ff000, 16384, PROT_READ) = 0
mprotect(0x63b5d7a98000, 4096, PROT_READ) = 0
mprotect(0x7757d249d000, 8192, PROT_READ) = 0
prlimit64(0, RLIMIT_STACK, NULL, {rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY}) = 0
munmap(0x7757d245f000, 20919)           = 0
rt_sigaction(SIGCHLD, {sa_handler=0x63b5d7a9649d, sa_mask=[CHLD], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x7757d2245330}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0
rt_sigaction(SIGUSR1, {sa_handler=0x63b5d7a96602, sa_mask=[USR1], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x7757d2245330}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0), ...}) = 0
getrandom("\x4a\xd4\x7e\xa6\x4e\x7c\xe5\x59", 8, GRND_NONBLOCK) = 8
brk(NULL)                               = 0x63b60b7ac000
brk(0x63b60b7cd000)                     = 0x63b60b7cd000
fstat(0, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0), ...}) = 0
write(1, "Enter result file name: ", 24) = 24
read(0, "out.txt\n", 1024)              = 8
write(1, "Enter numbers (separator - space"..., 35) = 35
read(0, "1 2 3 4 5\n", 1024)            = 10
openat(AT_FDCWD, "/dev/shm/shm", O_RDWR|O_CREAT|O_NOFOLLOW|O_CLOEXEC, 0666) = 3
ftruncate(3, 1024)                      = 0
mmap(NULL, 1024, PROT_READ|PROT_WRITE, MAP_SHARED, 3, 0) = 0x7757d2464000
close(3)                                = 0
clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7757d245ca10) = 44611
pause()                                 = ? ERESTARTNOHAND (To be restarted if no handler)
--- SIGUSR1 {si_signo=SIGUSR1, si_code=SI_USER, si_pid=44611, si_uid=1000} ---
rt_sigreturn({mask=[]})                 = -1 EINTR (Interrupted system call)
kill(44611, SIGUSR2)                    = 0
pause()                                 = ? ERESTARTNOHAND (To be restarted if no handler)
--- SIGUSR1 {si_signo=SIGUSR1, si_code=SI_USER, si_pid=44611, si_uid=1000} ---
--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=44611, si_uid=1000, si_status=0, si_utime=0, si_stime=0} ---
wait4(44611, [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], WNOHANG, NULL) = 44611
rt_sigreturn({mask=[USR1]})             = 0
write(1, "Child process completed succesfu"..., 37) = 37
write(1, "Result written to file.\n", 24) = 24
rt_sigreturn({mask=[]})                 = -1 EINTR (Interrupted system call)
munmap(0x7757d2464000, 1024)            = 0
unlink("/dev/shm/shm")                  = 0
exit_group(0)                           = ?
+++ exited with 0 +++
\end{verbatim}