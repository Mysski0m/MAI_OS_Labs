\section{Метод решения}

Для анализа корректности реализации лабораторных работ и подтверждения использования требуемых системных вызовов каждая из разработанных программ была запущена с использованием утилиты \texttt{strace}. Эта утилита позволяет перехватывать и логировать все системные вызовы, выполняемые процессом во время его работы, включая передаваемые аргументы и возвращаемые значения. \\
Для каждой лабораторной работы был сформирован отдельный лог-файл с помощью команды вида: \\
\texttt{strace -o labN.strace ./labN\_executable [аргументы]}, \\
где \texttt{labN.strace} — имя файла трассировки, а \texttt{labN\_executable} — исполняемый файл, соответствующий заданию лабораторной работы \texttt{N}. \\
После получения логов проводился их ручной и частично автоматизированный анализ с целью:
\begin{itemize}
    \item выявления ключевых системных вызовов, требуемых вариантом задания;
    \item проверки правильности их использования (порядок вызовов, обработка ошибок, корректность аргументов);
    \item подтверждения соответствия поведения программы ожидаемому сценарию работы (создание процессов, синхронизация, обмен данными и т.д.).
\end{itemize}
\vspace{1\baselineskip}

Ссылки:

\begin{itemize}
\item \url{https://man7.org/linux/man-pages/man1/strace.1.html}
\item \url{https://man7.org/linux/man-pages/man2/syscalls.2.html?spm=a2ty_o01.29997173.0.0.4d2f5171E111lX}
\item \url{https://man7.org/tlpi/?spm=a2ty_o01.29997173.0.0.4d2f5171E111lX}
\item \url{https://beej.us/guide/bgipc/?spm=a2ty_o01.29997173.0.0.4d2f5171E111lX}
\item \url{https://jvns.ca/strace-zine-v2.pdf?spm=a2ty_o01.29997173.0.0.4d2f5171E111lX&file=strace-zine-v2.pdf}
\item \url{https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md?spm=a2ty_o01.29997173.0.0.4d2f5171E111lX&file=syscalls.md}
\item \url{https://www.redhat.com/sysadmin/strace-tool?spm=a2ty_o01.29997173.0.0.4d2f5171E111lX}
\end{itemize}
\pagebreak

\section{Описание программы}
\section{Описание strace к Лабораторной работе №1}\\

\begin{lstlisting}
610   pipe2([3, 4], 0)                  = 0
610   pipe2([5, 6], 0)                  = 0
\end{lstlisting}
Создаёт первый канал (\texttt{pipe1}) для передачи данных от родительского процесса к дочернему. Дескриптор \texttt{3} — конец для чтения, \texttt{4} — конец для записи. В дальнейшем родитель запишет в \texttt{4}, а дочерний — прочитает из \texttt{3}. Это обеспечивает передачу пользовательских чисел \texttt{(1 2 3 4 5)} в дочерний процесс без использования глобальной памяти или файлов.\\
Создаёт второй канал (\texttt{pipe2}) для обратной связи — от дочернего процесса к родительскому. Дескриптор \texttt{5} — чтение (в родителе), \texttt{6} — запись (в дочернем). \\

\begin{lstlisting}
610   clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x78db7ebc2a10) = 611
\end{lstlisting}
Создаёт новый процесс (\texttt{PID 611}), который будет выполнять роль дочернего. Использование \texttt{clone()} с флагами, эквивалентными \texttt{fork()}, корректно для создания независимого процесса. Флаг \texttt{SIGCHLD} гарантирует, что родитель получит сигнал при завершении дочернего — важно для последующей синхронизации.\\

\begin{lstlisting}
611   dup2(3, 0 <unfinished ...>
610   write(4, "1 2 3 4 5\n", 10 <unfinished ...>
611   <... dup2 resumed>)               = 0
\end{lstlisting}
Перенаправляет чтение из канала 3 на стандартный ввод (\texttt{stdin}, дескриптор 0) дочернего процесса. Благодаря этому дочерняя программа (\texttt{./child}) может читать входные числа обычным read(0, ...) или \texttt{fgets(stdin)}, не зная, что данные пришли из канала, а не с терминала.\\

\begin{lstlisting}
610   close(4 <unfinished ...>
611   dup2(6, 2 <unfinished ...>
610   <... close resumed>)              = 0
\end{lstlisting}
Дочерний процесс закрывает ненужные концы каналов:\\
4 — запись в pipe1 (нужна только родителю).\\
Это обязательный шаг: если не закрыть, \texttt{read()} в родителе никогда не получит \texttt{EOF}, так как один конец канала останется открытым.\\

\begin{lstlisting}
611   execve("./child", ["./child", "ans.txt"], 0x7ffe06ad3be8 /* 27 vars */) = 0
\end{lstlisting}
Полностью заменяет образ дочернего процесса на исполняемый файл \texttt{./child}, передавая ему имя выходного файла (\texttt{ans.txt}) в качестве аргумента командной строки. Это прямое выполнение требования: «родительский и дочерний процесс должны быть представлены разными программами». Без этого вызова программа не соответствовала бы заданию.\\ \\ \\

\section{Описание strace к Лабораторной работе №2}\\

\begin{lstlisting}
execve("./main", ["./main", "--rounds", "10000000", "--max-threads", "12"], 0x7ffe35512550 /* 27 vars */) = 0
\end{lstlisting}
Запуск программы с аргументами: общее количество экспериментов (10 000 000 раундов) и ограничение на максимальное число потоков (12). Это соответствует требованию задания — количество потоков задаётся ключом запуска.\\

\begin{lstlisting}
clone3({flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, child_tid=0x7a07b57fb990, parent_tid=0x7a07b57fb990, exit_signal=0, stack=0x7a07b4ffb000, stack_size=0x7fff80, tls=0x7a07b57fb6c0} => {parent_tid=[40652]}, 88) = 40652
\end{lstlisting}
(и ещё 11 аналогичных вызовов с PID 40649–40659)
Создание 12 рабочих потоков с помощью системного вызова \texttt{clone3} с флагом \texttt{CLONE\_THREAD}. Это стандартный способ создания потоков в Linux при использовании библиотеки pthreads. Все потоки разделяют адресное пространство, открытые файлы и обработчики сигналов, но имеют собственные стеки и регистры — обеспечивая параллельное выполнение независимых раундов метода Монте-Карло.\\

\begin{lstlisting}
mmap(NULL, 8392704, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0x7a07b47fa000
mprotect(0x7a07b47fb000, 8388608, PROT_READ|PROT_WRITE) = 0
\end{lstlisting}
Выделение и настройка стека размером ~8 МБ для каждого нового потока. Это необходимая часть инициализации потока в POSIX-совместимых системах.\\

\begin{lstlisting}
futex(0x7a07b77ff990, FUTEX_WAIT_BITSET|FUTEX_CLOCK_REALTIME, 40648, NULL, FUTEX_BITSET_MATCH_ANY) = 0
\end{lstlisting}
(и аналогичные вызовы для остальных потоков)
Главный поток ожидает завершения рабочих потоков с помощью системного вызова \texttt{futex} — примитива синхронизации ядра Linux, лежащего в основе \texttt{pthread\_join()}. Это гарантирует, что вывод результата произойдёт только после окончания всех вычислений.\\

\section{Описание strace к Лабораторной работе №3}\\

\begin{lstlisting}
openat(AT_FDCWD, "/dev/shm/shm", O_RDWR|O_CREAT|O_NOFOLLOW|O_CLOEXEC, 0666) = 3
\end{lstlisting}
Создаёт именованный разделяемый объект в каталоге \texttt{/dev/shm} (tmpfs, RAM-backed файловая система). Это POSIX-совместимый способ организации разделяемой памяти через \texttt{memory-mapped} файлы, как того требует задание.\\

\begin{lstlisting}
ftruncate(3, 1024)                      = 0
\end{lstlisting}
Устанавливает размер разделяемого объекта в 1024 байта, чтобы гарантировать, что отображённая в память область имеет фиксированный размер — необходимо для корректной работы \texttt{mmap}.\\

\begin{lstlisting}
mmap(NULL, 1024, PROT_READ|PROT_WRITE, MAP_SHARED, 3, 0) = 0x7757d2464000
\end{lstlisting}
Отображает разделяемый файл в виртуальное адресное пространство родительского процесса с флагом \texttt{MAP\_SHARED}, что означает: все изменения в этой области будут видны другим процессам, отобразившим тот же файл. Это основной механизм обмена данными между процессами в данной лабораторной работе.\\

\begin{lstlisting}
pause()                                 = ? ERESTARTNOHAND (To be restarted if no handler)
\end{lstlisting}
Родительский процесс ожидает сигнала, блокируясь до получения любого сигнала. Это часть схемы синхронизации на основе сигналов.\\

\begin{lstlisting}
--- SIGUSR1 {si_signo=SIGUSR1, si_code=SI_USER, si_pid=44611, si_uid=1000} ---
\end{lstlisting}
Дочерний процесс отправил родителю пользовательский сигнал \texttt{SIGUSR1}, сигнализируя, например, о готовности данных или завершении вычислений. Это реализует взаимодействие через системные сигналы, как того требует задание.\\

\begin{lstlisting}
--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=44611, si_uid=1000, si_status=0, si_utime=0, si_stime=0} ---
\end{lstlisting}
Дочерний процесс завершился, и ядро уведомило родителя через сигнал \texttt{SIGCHLD} — стандартный механизм информирования о завершении дочернего процесса.\\

\begin{lstlisting}
wait4(44611, [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], WNOHANG, NULL) = 44611
\end{lstlisting}
Родитель явно собирает статус завершения дочернего процесса, предотвращая появление «зомби» процесса. \\

\begin{lstlisting}
munmap(0x7757d2464000, 1024)            = 0
\end{lstlisting}
Отменяет отображение разделяемой памяти из адресного пространства родителя после завершения работы.\\

\begin{lstlisting}
unlink("/dev/shm/shm")                  = 0
\end{lstlisting}
Удаляет разделяемый файл из файловой системы, освобождая ресурсы. Поскольку объект был создан в \texttt{/dev/shm}, его удаление не оставляет следов на диске.\\

\section{Описание strace к Лабораторной работе №4}\\

\begin{lstlisting}
openat(AT_FDCWD, "./libgcf_euclid.so", O_RDONLY|O_CLOEXEC) = 3
\end{lstlisting}
Программа открывает динамическую библиотеку \texttt{libgcf\_euclid.so} из текущего каталога. Это первая реализация контракта — вычисление НОД (GCF) с помощью алгоритма Евклида. Загрузка происходит во время исполнения, а не на этапе линковки.\\

\begin{lstlisting}
mmap(NULL, 16400, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x70b06d04c000
\end{lstlisting}
(и аналогичные mmap для кода и данных)
Ядро отображает содержимое библиотеки в виртуальное адресное пространство процесса:
\begin{itemize}
    \item \texttt{PROT\_READ|PROT\_EXEC} — для секции кода (.text),
    \item \texttt{PROT\_READ|PROT\_WRITE} — для секции данных (.data, .bss).
\end{itemize}
Это стандартный механизм загрузки ELF-объектов (\texttt{dlopen} внутри использует \texttt{mmap}).\\

\begin{lstlisting}
openat(AT_FDCWD, "./libtranslation_binary.so", O_RDONLY|O_CLOEXEC) = 3
\end{lstlisting}
Загружается вторая библиотека — реализация перевода числа в двоичную систему. Таким образом, программа использует две независимые библиотеки, каждая — для своей функции (1 и 2).\\

\begin{lstlisting}
read(0, "0\n", 1024)                    = 2
\end{lstlisting}
Пользователь вводит команду «0» — запрос на переключение реализации.\\

\begin{lstlisting}
openat(AT_FDCWD, "./libgcf_naive.so", O_RDONLY|O_CLOEXEC) = 3
...
openat(AT_FDCWD, "./libtranslation_ternary.so", O_RDONLY|O_CLOEXEC) = 3
\end{lstlisting}
После команды 0 программа загружает альтернативные реализации:
\begin{itemize}
    \item \texttt{libgcf\_naive.so} — НОД через перебор,
    \item \texttt{libtranslation\_ternary.so} — перевод в троичную систему.
\end{itemize}
Это демонстрирует динамическое переключение контрактов во время выполнения.\\

\begin{lstlisting}
munmap(0x70b06d04c000, 16400)           = 0
...
munmap(0x70b06cf2a000, 16416)           = 0
\end{lstlisting}
Прежние библиотеки выгружаются из памяти (через \texttt{dlclose}, который вызывает \texttt{munmap}). Это предотвращает утечки памяти и позволяет корректно заменить реализации.\\

\begin{lstlisting}
getcwd("/home/yamaksush/MAI_OS_Labs/lab4-var25/build", 128) = 45
\end{lstlisting}
Программа определяет текущий рабочий каталог, чтобы корректно разрешать относительные пути к библиотекам (\texttt{./lib...so}). Это соответствует требованию: «загружать библиотеки, используя только их относительные пути».

\begin{lstlisting}
openat(AT_FDCWD, "/home/yamaksush/MAI_OS_Labs/lab4-var25/build/libgcf_euclid.so", O_RDONLY|O_CLOEXEC) = 3
\end{lstlisting}
Программа загружает динамическую библиотеку \texttt{libgcf\_euclid.so} при старте, потому что она была указана в качестве зависимости на этапе линковки (\texttt{-lgcf\_euclid}). В отличие от \texttt{main\_runtime}, здесь нет вызова \texttt{dlopen} — загрузка происходит автоматически загрузчиком (ld-linux.so).\\

\pagebreak