\section{Выводы}
В результате выполнения лабораторных работ было получено четыре файла трассировки (\texttt{lab1.strace}, \texttt{lab2.strace}, \texttt{lab3.strace}, \texttt{lab4\_runtime.strace}, \texttt{lab4\_link.strace}), содержащих полные журналы системных вызовов, выполненных каждой из программ. Анализ этих логов подтвердил, что:
\begin{itemize}
    \item программы используют именно те системные вызовы, которые требуются в соответствии с заданием каждой лабораторной работы;
    \item все критически важные операции (создание процессов, работа с сигналами, использование разделяемой памяти, синхронизация, обработка ошибок) реализованы корректно на уровне системных вызовов;
    \item поведение программ соответствует ожидаемому: процессы создаются и завершаются в нужном порядке, межпроцессное взаимодействие осуществляется штатно, ошибки обрабатываются с использованием стандартных механизмов (errno, проверка возвращаемых значений).
\end{itemize}\\
Лабораторная работа 1:\\
Родительский процесс (PID 610) создаёт два канала (pipe2) и один дочерний процесс через clone(). Дочерний процесс перенаправляет stdin на чтение из первого канала с помощью dup2(3, 0), а stderr — на запись во второй канал (dup2(6, 2)), после чего загружает отдельную программу ./child через execve("./child", ["./child", "ans.txt"], ...). Родитель передаёт строку чисел (1 2 3 4 5) через write(4, ...), дочерний читает её, вычисляет последовательное деление (1/2/3/4/5 = 0.008333), записывает результат в файл ans.txt через openat и write, и завершается с кодом 0. Родитель получает SIGCHLD, читает EOF из обратного канала. Требование о двух разных программах выполнено благодаря execve.\\

Лабораторная работа 2:\\
Главный процесс (PID 44592) запускается с аргументами --rounds 10000000 --max-threads 12 и создаёт 12 рабочих потоков с помощью clone3(..., CLONE\_THREAD, ...). Каждый поток получает выделенный стек (примерно 8 МБ) через mmap(..., MAP\_STACK). Все потоки совместно участвуют в методе Монте-Карло: генерируют случайные «колоды», проверяют совпадение рангов первых двух карт. Синхронизация завершения осуществляется через futex(..., FUTEX\_WAIT\_BITSET, ...) — аналог pthread\_join. Результат: 587118 успешных исходов из 10 000 000 → вероятность 0.0587118 (примерно 3/51), что соответствует теории. Время выполнения (5.115 с) позволяет провести анализ ускорения.\\

Лабораторная работа 3:\\
Родительский процесс (PID 44592) создаёт разделяемый объект в оперативной памяти через openat("/dev/shm/shm", O\_CREAT), устанавливает его размер на 1024 байта (ftruncate) и отображает в память с помощью mmap(..., MAP\_SHARED, ...). Затем создаёт дочерний процесс через clone(). Синхронизация осуществляется через сигналы: дочерний отправляет SIGUSR1 родителю через kill, родитель отвечает SIGUSR2. После завершения дочернего (SIGCHLD) родитель собирает статус через wait4, отменяет отображение памяти (munmap) и удаляет разделяемый объект (unlink). Взаимодействие реализовано как через memory-mapped файлы, так и через сигналы — в полном соответствии с заданием.\\

Лабораторная работа 4 (статическая линковка):\\
Программа main\_link загружается через execve и автоматически подгружает libgcf\_euclid.so и libtranslation\_binary.so при старте, так как они указаны в зависимостях на этапе линковки. Обе библиотеки отображаются в память через mmap ещё до входа в main(). Пользователь может вызывать функции: команда 1 10 5 → GCF(10, 5) = 5, команда 2 19 → Translation(19) = 10011 (двоичная система). Однако переключение реализаций невозможно — программа жёстко привязана к euclid и binary версиям. Это демонстрирует классический подход link-time binding: быстрый, но негибкий.\\

Лабораторная работа 4 (динамическая загрузка):\\
Программа main\_runtime не зависит от конкретных библиотек на этапе компиляции. При запуске она загружает libgcf\_euclid.so и libtranslation\_binary.so через openat + mmap (внутренне — dlopen). При вводе команды 0 программа выгружает текущие реализации (munmap) и загружает альтернативные: libgcf\_naive.so и libtranslation\_ternary.so. Вызовы функций перенаправляются через указатели. Пример: 1 10 6 → GCF = 2 (сначала через Евклид, после переключения — через наивный алгоритм); 2 48 → 1210 (троичная система). Это демонстрирует runtime binding: гибкий, поддерживающий hot-swap реализаций без перекомпиляции, но с небольшими накладными расходами.\\

Все реализации корректны на уровне системных вызовов. Архитектурные различия между подходами (процессы vs потоки, pipes vs shared memory, link-time vs runtime linking) чётко прослеживаются в strace и соответствуют теоретическим основам операционных систем.

\pagebreak